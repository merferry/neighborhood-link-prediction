\begin{algorithm}[hbtp]
\caption{Our Parallel Link Prediction algorithm.}
\label{alg:predict}
\begin{algorithmic}[1]
\Require{$G(V, E)$: Input graph}
\Require{$N_P$: Maximum number of edges to predict}
\Require{$S_{min}$: Minimum score above which to predict}
\Ensure{$i, j, k$: Current vertex, first order, second order neighbor}
\Ensure{$\Pi_j$: Maximum allowed degree of first order neighbor $j$}
\Ensure{$D_j$: Degree of first order neighbor $j$}
\Ensure{$H_t$: Collision-free per-thread hashtable}
\Ensure{$P_t$: Per-thread prediction list}
\Ensure{$P_h$: Heap for merging per-thread prediction lists}
\Ensure{$P$: Global prediction list}

\Statex

\Function{predictLinks}{$G, N_P, S_{min}$} \label{alg:predict--begin}
  \State $\rhd$ Scoring phase
  \State $P_t \gets \{\}$ \textbf{on each thread} \label{alg:predict--scoring-begin}
  \ForAll{$i \in V$ \textbf{in parallel}}
    \State $\rhd$ Scan second order neighbors of $i$
    \State $H_t \gets \{\}$
    \ForAll{$j \in G.out(i)$}
      \State $\rhd$ Skip high degree first order neighbors
      \If{$D_j \leq \Pi_j$} $scanEdges(H_t, G, j)$
      \EndIf
    \EndFor
    \State $\rhd$ Avoid first order neighbors
    \ForAll{$j \in G.out(i)$} $H_t[j] \gets 0$ \label{alg:predict--avoid-neighbors1}
    \EndFor
    \State $\rhd$ Get prediction scores and add to list
    \ForAll{$k \in H_t.keys()$}
      \State $score \gets computeScore(i, k, H_t[k])$
      \If{$score \leq S_{min}$} \textbf{continue}
      \EndIf
      \State $\rhd$ Add edge $(i, k)$ to prediction list
      \If{$|P_t| < N_P$}
        \State $P_t.push(\{i, k, score\})$
        \If{$|P_t| = N_P$} $P_t.makeMinHeapByScore()$
        \EndIf
      \ElsIf{$score \geq P_t[0].score$}
        \State $P_t.popHeap()$
        \State $P_t.pushHeap(\{i, k, score\})$
      \EndIf
    \EndFor
  \EndFor \label{alg:predict--scoring-end}
  \State $\rhd$ Merging phase \label{alg:predict--merging-begin}
  \State $P \gets \{\}$ \textbf{;} $P_h \gets \{\}$
  \State $sort(P_t)$ \textbf{on each thread}
  \ForAll{$t$ in threads}
    \If{$|P_t| \neq 0$} $P_h.push(\{t, P_t.back().score\})$
    \EndIf
  \EndFor
  \State $P_h.makeMaxHeapByScore()$ 
  \While{$|P_h| \neq 0$ \textbf{and} $|P| < N_P$} \label{alg:predict--merge-loop-begin}
    \State $t \gets P_h.popHeap().t$
    \State $P.push(P_t.back())$
    \State $P_t.pop()$
    \If{$|P_t| \neq 0$} $P_h.pushHeap(\{t, P_t.back().score\})$
    \EndIf
  \EndWhile \label{alg:predict--merging-end}
  \Return{$P$}
\EndFunction \label{alg:predict--end}

\Statex

\Function{scanEdges}{$H_t, G, i, j$} \label{alg:predict--scan-begin}
  \ForAll{$k \in G.out(j)$}
    \State $\rhd$ Skip reverse edges
    \If{$k \leq i$} \textbf{continue}
    \EndIf
    \If{$metric = AA$} $H_t[k] \gets H_t[k] + 1 / log(D_j)$
    \ElsIf{$metric = RA$} $H_t[k] \gets H_t[k] + 1 / D_j$
    \Else\ $H_t[k] \gets H_t[k] + 1$
    \EndIf
  \EndFor
\EndFunction \label{alg:predict--scan-end}
\end{algorithmic}
\end{algorithm}
